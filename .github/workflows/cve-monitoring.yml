#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Update & enrich CVE watch JSON stored at: data/vuln-watch.json

- Compatible with schema:
  {
    "vulnerabilities": {
      "CVE-XXXX-YYYY": { ... }
    }
  }

Enrichments:
- metrics.epss.current + metrics.epss.percentile (FIRST EPSS API)
- metrics.kev_status.current + metrics.kev_status.date_added (CISA KEV feed)
- dates.monitoring_start (if missing) + dates.last_check (always updated)
- watchtower.priority: score + level + signals (Remote + KEV + EPSS)
- watchtower.review: last_review + next_review + frequency_days + rationale

Safe: never deletes existing fields, only adds/updates known ones.
"""

from __future__ import annotations

import json
import os
from datetime import datetime, timezone, timedelta
from pathlib import Path
from typing import Any, Dict, Optional, Tuple

import requests


DATA_FILE = Path("data/vuln-watch.json")

EPSS_API = "https://api.first.org/data/v1/epss"
CISA_KEV_FEED = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json"

HTTP_TIMEOUT = 20  # seconds


def now_utc() -> datetime:
    return datetime.now(timezone.utc)


def iso(dt: datetime) -> str:
    return dt.astimezone(timezone.utc).replace(microsecond=0).isoformat().replace("+00:00", "Z")


def load_json(path: Path) -> Dict[str, Any]:
    if not path.exists():
        raise FileNotFoundError(f"Missing JSON file: {path}")
    with path.open("r", encoding="utf-8") as f:
        return json.load(f)


def save_json(path: Path, data: Dict[str, Any]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)
        f.write("\n")


def ensure_dict(container: Dict[str, Any], key: str) -> Dict[str, Any]:
    if key not in container or not isinstance(container[key], dict):
        container[key] = {}
    return container[key]


def ensure_list(container: Dict[str, Any], key: str) -> list:
    if key not in container or not isinstance(container[key], list):
        container[key] = []
    return container[key]


def fetch_epss(cve_id: str) -> Optional[Tuple[float, Optional[float]]]:
    """
    Returns: (epss_score [0..1], percentile [0..1 or None])
    """
    try:
        r = requests.get(EPSS_API, params={"cve": cve_id}, timeout=HTTP_TIMEOUT)
        r.raise_for_status()
        payload = r.json()
        data = payload.get("data") or []
        if not data:
            return None
        rec = data[0]
        # EPSS API returns strings sometimes
        score = float(rec.get("epss")) if rec.get("epss") is not None else None
        pct = float(rec.get("percentile")) if rec.get("percentile") is not None else None
        if score is None:
            return None
        return score, pct
    except Exception:
        return None


def fetch_kev_catalog() -> Optional[Dict[str, Any]]:
    try:
        r = requests.get(CISA_KEV_FEED, timeout=HTTP_TIMEOUT)
        r.raise_for_status()
        return r.json()
    except Exception:
        return None


def find_kev_entry(catalog: Dict[str, Any], cve_id: str) -> Optional[Dict[str, Any]]:
    # CISA feed structure: {"vulnerabilities":[{ "cveID": "...", "dateAdded":"YYYY-MM-DD", ...}, ...]}
    vulns = catalog.get("vulnerabilities") if isinstance(catalog, dict) else None
    if not isinstance(vulns, list):
        return None
    for v in vulns:
        if isinstance(v, dict) and v.get("cveID") == cve_id:
            return v
    return None


def is_remote_exploitable(vuln: Dict[str, Any]) -> bool:
    """
    Derive "Remote exploitable" from exploitation_conditions.attack_vector
    - True if contains "remote" OR "network" (case-insensitive)
    - Otherwise False
    """
    ec = vuln.get("exploitation_conditions")
    if not isinstance(ec, dict):
        return False
    av = str(ec.get("attack_vector") or "").lower()
    return ("remote" in av) or ("network" in av)


def compute_priority(remote: bool, kev: bool, epss_current: Optional[float]) -> Dict[str, Any]:
    """
    Priority score: Remote + KEV + EPSS
    - EPSS in [0..1] => epss_points in [0..5] via *5
    - Remote => +2
    - KEV    => +3
    Total => [0..10] capped

    Level:
    - CRITICAL: score >= 8  OR (KEV and epss>=0.20) OR (KEV and remote)
    - HIGH    : score >= 6
    - MEDIUM  : score >= 3
    - LOW     : else
    """
    epss = float(epss_current) if isinstance(epss_current, (int, float)) else 0.0
    epss = max(0.0, min(1.0, epss))

    epss_points = epss * 5.0
    score = epss_points + (2.0 if remote else 0.0) + (3.0 if kev else 0.0)
    score = round(min(10.0, score), 2)

    if score >= 8.0 or (kev and epss >= 0.20) or (kev and remote):
        level = "CRITICAL"
    elif score >= 6.0:
        level = "HIGH"
    elif score >= 3.0:
        level = "MEDIUM"
    else:
        level = "LOW"

    return {
        "score": score,
        "level": level,
        "signals": {
            "remote_exploitable": remote,
            "kev": kev,
            "epss_current": round(epss, 4)
        }
    }


def compute_review_schedule(priority_level: str, status: str) -> Tuple[int, str]:
    """
    Returns: (frequency_days, rationale)
    - closed/mitigated => 90 days (or keep for archival monitoring)
    - CRITICAL => 7 days
    - HIGH => 14 days
    - MEDIUM => 30 days
    - LOW => 60 days
    """
    st = (status or "").lower()
    if st in ("closed", "mitigated"):
        return 90, "Status mitigated/closed: revue espacée (archivage/monitoring)."

    if priority_level == "CRITICAL":
        return 7, "Priorité CRITICAL (Remote/KEV/EPSS élevé): revue hebdomadaire."
    if priority_level == "HIGH":
        return 14, "Priorité HIGH: revue toutes les 2 semaines."
    if priority_level == "MEDIUM":
        return 30, "Priorité MEDIUM: revue mensuelle."
    if priority_level == "LOW":
        return 60, "Priorité LOW: revue bimestrielle."

    return 30, "Priorité non déterminée: revue mensuelle par défaut."


def ensure_dates(vuln: Dict[str, Any], now: datetime) -> None:
    dates = ensure_dict(vuln, "dates")
    # do not overwrite published/updated if present
    if "monitoring_start" not in dates or not dates.get("monitoring_start"):
        dates["monitoring_start"] = iso(now)
    dates["last_check"] = iso(now)


def ensure_metrics(vuln: Dict[str, Any]) -> Dict[str, Any]:
    metrics = ensure_dict(vuln, "metrics")

    # epss structure
    epss = ensure_dict(metrics, "epss")
    # keep epss.initial if already set; else set when we first ever got a current
    if "initial" not in epss:
        epss["initial"] = None
    if "current" not in epss:
        epss["current"] = None
    if "percentile" not in epss:
        epss["percentile"] = None

    # kev_status structure
    kev = ensure_dict(metrics, "kev_status")
    if "initial" not in kev:
        kev["initial"] = False
    if "current" not in kev:
        kev["current"] = False
    if "date_added" not in kev:
        kev["date_added"] = None

    # cvss structure (keep as-is if already there)
    ensure_dict(metrics, "cvss")

    return metrics


def update_one_vuln(vuln: Dict[str, Any], cve_id: str, now: datetime, kev_catalog: Optional[Dict[str, Any]]) -> None:
    # Ensure identity
    vuln["cve_id"] = vuln.get("cve_id") or cve_id

    # Dates
    ensure_dates(vuln, now)

    # Metrics scaffolding
    metrics = ensure_metrics(vuln)
    epss = metrics["epss"]
    kev = metrics["kev_status"]

    # --- EPSS update ---
    epss_info = fetch_epss(cve_id)
    if epss_info is not None:
        epss_current, epss_pct = epss_info
        # set initial if missing/null
        if epss.get("initial") in (None, "", 0) and isinstance(epss_current, float):
            epss["initial"] = round(float(epss_current), 4)
        epss["current"] = round(float(epss_current), 4)
        epss["percentile"] = round(float(epss_pct), 4) if epss_pct is not None else epss.get("percentile")

    # --- KEV update ---
    kev_hit = False
    kev_date = None
    if kev_catalog is not None:
        entry = find_kev_entry(kev_catalog, cve_id)
        if entry is not None:
            kev_hit = True
            kev_date = entry.get("dateAdded")

    # preserve "initial" meaning: first time we observe KEV
    if kev_hit and not kev.get("current", False):
        if not kev.get("initial", False):
            kev["initial"] = False  # keep semantics; initial is what was recorded at start of monitoring
        kev["current"] = True
        if kev_date:
            kev["date_added"] = kev_date
    elif not kev_hit:
        # do NOT flip to false if you want sticky behaviour; here we keep it reflecting current catalog
        kev["current"] = False if kev.get("current") is False else kev.get("current", False)

    # --- Priority + Review schedule ---
    remote = is_remote_exploitable(vuln)
    kev_current = bool(kev.get("current"))
    epss_current_val = epss.get("current")
    prio = compute_priority(remote=remote, kev=kev_current, epss_current=epss_current_val)

    wt = ensure_dict(vuln, "watchtower")
    wt["priority"] = prio

    freq_days, rationale = compute_review_schedule(prio["level"], vuln.get("status", "active"))

    review = ensure_dict(wt, "review")
    # keep last_review if already present; otherwise set now (first time enrichment)
    if not review.get("last_review"):
        review["last_review"] = iso(now)
    review["frequency_days"] = freq_days
    review["next_review"] = iso(now + timedelta(days=freq_days))
    review["rationale"] = rationale


def main() -> int:
    data = load_json(DATA_FILE)

    vulns = data.get("vulnerabilities")
    if not isinstance(vulns, dict):
        raise ValueError("Invalid JSON schema: root.vulnerabilities must be an object/dict")

    now = now_utc()

    # Keep / create meta without deleting anything
    meta = data.get("meta")
    if not isinstance(meta, dict):
        data["meta"] = {}
        meta = data["meta"]
    meta["generated_at"] = iso(now)

    # Load KEV catalog once
    kev_catalog = fetch_kev_catalog()

    # Update all CVEs
    for cve_id, vuln in vulns.items():
        if not isinstance(vuln, dict):
            continue
        update_one_vuln(vuln, cve_id, now, kev_catalog)

    save_json(DATA_FILE, data)
    print(f"Updated {len(vulns)} CVE entries in {DATA_FILE}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
